<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crosswords#3 - January 2026</title>

  <style>
    :root { --cell: 40px; --border: #111; }

    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 18px;
      color: #111;
      background: #eaf7ea; /* soft light green */
    }

    h1 { margin: 0 0 8px; font-size: 34px; }

    .instructions {
      margin: 0 0 14px;
      font-size: 14px;
      line-height: 1.35;
    }

    .layout {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 20px;
      align-items: start;
    }

    /* Responsive: on small screens put clues below */
    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(15, var(--cell));
      grid-template-rows: repeat(15, var(--cell));
      user-select: none;
      border: 0;
      background: transparent;
    }

    .cell {
      position: relative;
      width: var(--cell);
      height: var(--cell);
      border: 1px solid var(--border);
      box-sizing: border-box;
      background: #fff;
    }

    .cell.block {
      background: #000;
    }

    .num {
      position: absolute;
      top: 2px;
      left: 3px;
      font-size: 10px;
      font-weight: normal;
      line-height: 1;
      color: #111;
      pointer-events: none;
    }

    .ch {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 18px;
      color: #111;
      pointer-events: none;
    }

    .ch.wrong-letter {
      color: #c1121f; /* red for wrong letters */
    }

    .cell.selected {
      outline: 3px solid #3b82f6;
      outline-offset: -3px;
    }

    .cell.in-word {
      background: #eef6ff;
    }

    .cell.block.selected,
    .cell.block.in-word {
      outline: none;
      background: #000;
    }

    /* Blink feedback (word highlight) */
    @keyframes blinkGreen { 0%,100%{ background:#e8fff0; } 50%{ background:#9ef0b7; } }
    @keyframes blinkRed   { 0%,100%{ background:#ffecec; } 50%{ background:#ff9a9a; } }

    .blink-green { animation: blinkGreen 420ms ease-in-out 0s 2; }
    .blink-red   { animation: blinkRed   420ms ease-in-out 0s 2; }

    /* Clues */
    .panel h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }

    .panel h3 {
      margin: 14px 0 6px;
      font-size: 15px;
    }

    .clues {
      columns: 2;
      column-gap: 18px;
    }

    @media (max-width: 980px) {
      .clues { columns: 1; }
    }

    .clue {
      break-inside: avoid;
      margin: 0 0 7px;
      font-size: 13px;
      line-height: 1.25;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin: 0 0 12px;
    }

    button {
      padding: 7px 10px;
      border: 1px solid #bbb;
      background: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover { background: #f4f4f4; }

    .status {
      font-size: 13px;
      color: #333;
    }

    /* Hidden input for mobile keyboard reliability */
    input.hidden {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }
  </style>
</head>

<body>
  <h1>Crosswords#3 - January 2026</h1>

  <p class="instructions">
    Click once to select words <b>ACROSS</b>, click a second time on the square to select the words <b>DOWN</b>.
  </p>

  <p class="instructions">
    Source: adapted for educational purposes from Fleming, Puzzle 4.
  </p>

  <p class="instructions">
    Good luck!
  </p>

  <div class="toolbar">
    <button id="toggleDir">Direction: <b id="dirLabel">ACROSS</b></button>
    <button id="checkWord">Check word</button>
    <button id="clearWord">Clear word</button>
    <span class="status" id="status"></span>
  </div>

  <div class="layout">
    <div>
      <div id="grid" class="grid" aria-label="Crossword grid"></div>
      <input id="kbd" class="hidden" inputmode="latin" autocomplete="off" autocapitalize="characters" />
    </div>

    <div class="panel">
      <h2>Clues</h2>

      <h3>Across</h3>
      <div class="clues" id="acrossClues"></div>

      <h3>Down</h3>
      <div class="clues" id="downClues"></div>
    </div>
  </div>

<script>
/* SOLUTION GRID (Crossword #3 exact 15x15) */
const SOLUTION_ROWS = [
  "DRILL#ARAB#MUM#",
  "RADIO#MARE#USES",
  "ARENT#ONCE#SURE",
  "WEAK#RUG##CHART",
  "###STUN#HOURLY#",
  "EGG#WIT#INTO###",
  "CRAYON#AGO#ORAL",
  "HATES#ASH#AMUSE",
  "ONES#INK#RUSSIA",
  "###TENT#PEN#HAD",
  "#CLEANS#RATS###",
  "ALERT##OIL#HEAR",
  "LOAD#WEVE#BADGE",
  "LAVA#EYES#URGED",
  "#KEY#BENT#SEEDS",
];

/* ACROSS CLUES (by number) */
const ACROSS_CLUES = {
  1:  "Tool for making holes",
  6:  "Person from the Middle East",
  10: "Silent; also a mother (informal)",

  13: "Broadcast device",
  14: "Adult female horse",
  15: "Employs",

  17: "“Are not,” colloquially",
  18: "One time",
  19: "Certain",

  20: "Lacking strength",
  21: "Small floor covering",
  22: "Diagram or map",

  23: "Astonish",
  25: "Happening every sixty minutes",

  27: "Oval breakfast item",
  30: "Sharp intelligence",
  31: "Interested in; absorbed by",

  32: "Coloring stick",
  34: "In the past",
  35: "Spoken, not written",

  39: "Strongly dislikes",
  40: "Burnt residue",
  41: "Entertain",

  42: "Certain people or things",
  43: "Pen fluid",
  44: "World’s largest country",

  45: "Temporary shelter",
  47: "Writing instrument",
  48: "Possessed formerly",

  49: "Makes tidy",
  51: "Rodents",

  53: "Watchful",
  54: "Slippery liquid",
  55: "Perceive sound",

  59: "Burden",
  60: "“We have,” informally",
  62: "Insignia",

  63: "Molten rock",
  64: "Organs of sight",
  65: "Pressed strongly",

  66: "Door opener",
  67: "Curved",
  68: "Plant starters",
};

/* DOWN CLUES (list of [number, answer, clue]) */
const DOWN_LIST = [
  [1,  "DRAW",      "Make a sketch"],
  [2,  "RARE",      "Uncommon"],
  [3,  "IDEA",      "A thought or plan"],
  [4,  "LINKS",     "Connections"],
  [5,  "LOT",       "A bunch"],
  [6,  "AMOUNT",    "Quantity"],
  [7,  "RANG",      "Sounded (past tense of “ring”)"],
  [8,  "ARC",       "A curved line"],
  [9,  "BEE",       "Honey-making insect"],
  [10, "MUSHROOMS", "Fungi you might cook or eat"],
  [11, "USUAL",     "Normal; typical"],
  [12, "MERRY",     "Cheerful"],

  [16, "SET",       "Put in place"],

  [21, "RUIN",      "Destroy"],
  [22, "CUT",       "Slice"],

  [24, "TWOS",      "Pairs (plural)"],
  [25, "HIGH",      "Not low"],
  [26, "ONO",       "Yoko ___"],

  [27, "ECHO",      "Reflected sound"],
  [28, "GRAN",      "Grandma (informal)"],
  [29, "GATE",      "Hinged barrier"],

  [33, "YESTERDAY", "The day before today"],
  [34, "ASK",       "Inquire"],
  [36, "RUSH",      "Hurry"],
  [37, "ASIA",      "Earth’s largest continent"],
  [38, "LEAD",      "Guide"],

  [40, "ANTS",      "Small insects that live in colonies"],
  [41, "AUNT",      "Parent’s sister"],

  [43, "INN",       "Small hotel"],
  [44, "REAL",      "Not imaginary"],

  [46, "EAT",       "Consume food"],
  [47, "PRIEST",    "Ordained religious minister"],

  [49, "CLOAK",     "Cape-like covering"],
  [50, "LEAVE",     "Depart"],
  [52, "SHARE",     "Divide with others"],

  [53, "ALL",       "Every one"],
  [54, "OVEN",      "Kitchen appliance for baking"],
  [56, "EDGE",      "Border"],
  [57, "AGED",      "Old; mature"],
  [58, "REDS",      "Some wines, informally"],

  [60, "WEB",       "Spider’s trap"],
  [61, "EYE",       "Organ of sight"],
  [62, "BUS",       "Public transport vehicle"],
];

const H = 15, W = 15;
const gridEl = document.getElementById("grid");
const kbd = document.getElementById("kbd");
const statusEl = document.getElementById("status");

const isBlock = (r,c) => SOLUTION_ROWS[r][c] === "#";
const sol = (r,c) => SOLUTION_ROWS[r][c];
const user = Array.from({length:H}, () => Array.from({length:W}, () => ""));

let dir = "across";
let selected = {r:0,c:0};

const cellEls = Array.from({length:H}, () => Array.from({length:W}, () => null));

/* compute numbering */
const nums = Array.from({length:H}, () => Array.from({length:W}, () => null));
(function computeNumbers(){
  let n = 1;
  for (let r=0;r<H;r++){
    for (let c=0;c<W;c++){
      if (isBlock(r,c)) continue;
      const startAcross = (c===0 || isBlock(r,c-1)) && (c+1<W && !isBlock(r,c+1));
      const startDown   = (r===0 || isBlock(r-1,c)) && (r+1<H && !isBlock(r+1,c));
      if (startAcross || startDown) nums[r][c] = n++;
    }
  }
})();

function firstOpenCell(){
  for (let r=0;r<H;r++) for (let c=0;c<W;c++) if (!isBlock(r,c)) return {r,c};
  return {r:0,c:0};
}
selected = firstOpenCell();

function renderGrid(){
  gridEl.innerHTML = "";
  for (let r=0;r<H;r++){
    for (let c=0;c<W;c++){
      const d = document.createElement("div");
      d.className = "cell" + (isBlock(r,c) ? " block" : "");
      d.dataset.r = r; d.dataset.c = c;

      if (!isBlock(r,c) && nums[r][c] != null){
        const n = document.createElement("div");
        n.className = "num";
        n.textContent = nums[r][c];
        d.appendChild(n);
      }

      if (!isBlock(r,c)){
        const ch = document.createElement("div");
        ch.className = "ch";
        ch.textContent = user[r][c];
        d.appendChild(ch);
      }

      d.addEventListener("mousedown", (e)=>{
        e.preventDefault();

        // click same square toggles direction across <-> down
        if (selected.r === r && selected.c === c) {
          toggleDirInternal();
        } else {
          selectCell(r,c);
        }

        kbd.focus();
      });

      gridEl.appendChild(d);
      cellEls[r][c] = d;
    }
  }
  paintSelection();
}

function setStatus(msg){ statusEl.textContent = msg || ""; }

function setDir(newDir){
  dir = newDir;
  document.getElementById("dirLabel").textContent = dir.toUpperCase();
  paintSelection();
}

function toggleDirInternal(){
  setDir(dir === "across" ? "down" : "across");
}

document.getElementById("toggleDir").addEventListener("click", ()=>{
  toggleDirInternal();
  kbd.focus();
});
document.getElementById("checkWord").addEventListener("click", ()=>{
  checkCurrentWord(true);
  kbd.focus();
});
document.getElementById("clearWord").addEventListener("click", ()=>{
  clearCurrentWord();
  kbd.focus();
});

function selectCell(r,c){
  if (isBlock(r,c)) return;
  selected = {r,c};
  paintSelection();
}

function getWordCells(r,c,dir){
  let sr=r, sc=c;
  if (dir==="across"){
    while (sc>0 && !isBlock(sr, sc-1)) sc--;
    const cells=[];
    while (sc<W && !isBlock(sr, sc)) { cells.push({r:sr,c:sc}); sc++; }
    return cells;
  } else {
    while (sr>0 && !isBlock(sr-1, sc)) sr--;
    const cells=[];
    while (sr<H && !isBlock(sr, sc)) { cells.push({r:sr,c:sc}); sr++; }
    return cells;
  }
}

function paintSelection(){
  for (let r=0;r<H;r++) for (let c=0;c<W;c++){
    const el = cellEls[r][c];
    if (!el) continue;
    el.classList.remove("selected","in-word");
  }

  const word = getWordCells(selected.r, selected.c, dir);
  for (const p of word) cellEls[p.r][p.c].classList.add("in-word");
  cellEls[selected.r][selected.c].classList.add("selected");

  const wStart = word[0];
  const n = nums[wStart.r][wStart.c];
  if (n != null){
    const clue = (dir==="across")
      ? (ACROSS_CLUES[n] || "")
      : (DOWN_LIST.find(x=>x[0]===n)?.[2] || "");
    setStatus(`${dir.toUpperCase()} ${n}: ${clue}`);
  } else {
    setStatus("");
  }
}

function move(deltaR, deltaC){
  let r=selected.r, c=selected.c;
  while (true){
    r += deltaR; c += deltaC;
    if (r<0||r>=H||c<0||c>=W) return;
    if (!isBlock(r,c)) { selectCell(r,c); return; }
  }
}

function nextCell(){ (dir==="across") ? move(0,1) : move(1,0); }
function prevCell(){ (dir==="across") ? move(0,-1) : move(-1,0); }

function setLetterAt(r,c,letter){
  user[r][c] = letter;
  const ch = cellEls[r][c].querySelector(".ch");
  if (ch) {
    ch.textContent = letter;

    // instant per-square correctness coloring
    if (letter && letter.toUpperCase() !== sol(r,c).toUpperCase()) ch.classList.add("wrong-letter");
    else ch.classList.remove("wrong-letter");
  }
}

function blinkCells(cells, color){
  const cls = (color==="green") ? "blink-green" : "blink-red";
  for (const p of cells){
    const el = cellEls[p.r][p.c];
    el.classList.remove("blink-green","blink-red");
    void el.offsetWidth; // restart animation
    el.classList.add(cls);
    el.addEventListener("animationend", ()=>el.classList.remove(cls), {once:true});
  }
}

function checkWordCells(cells, withBlink){
  const userWord = cells.map(p => (user[p.r][p.c] || "")).join("");
  const solWord  = cells.map(p => sol(p.r,p.c)).join("");

  if ([...userWord].some(ch => !ch)) return null; // incomplete

  const ok = userWord.toUpperCase() === solWord.toUpperCase();
  if (withBlink) blinkCells(cells, ok ? "green" : "red");
  return ok;
}

function checkCurrentWord(withBlink){
  const cells = getWordCells(selected.r, selected.c, dir);
  const ok = checkWordCells(cells, withBlink);
  if (ok === null) { setStatus("Fill the entire word to check."); return false; }
  setStatus(ok ? "Correct." : "Not correct yet.");
  return ok;
}

function clearCurrentWord(){
  const cells = getWordCells(selected.r, selected.c, dir);
  for (const p of cells) setLetterAt(p.r,p.c,"");
  setStatus("Cleared word.");
}

function handleChar(ch){
  if (!/^[A-Za-z]$/.test(ch)) return;

  // capture the CURRENT word before we move the cursor
  const activeWordCells = getWordCells(selected.r, selected.c, dir);

  setLetterAt(selected.r, selected.c, ch.toUpperCase());

  // if after inserting the letter the active word is complete, blink THAT same word
  const complete = activeWordCells.every(p => user[p.r][p.c]);

  nextCell();

  if (complete) {
    // blink the word that was just completed (not whatever we moved into)
    checkWordCells(activeWordCells, true);
  }
}

document.addEventListener("keydown", (e)=>{
  const key = e.key;

  if (key === "Tab") { e.preventDefault(); toggleDirInternal(); return; }

  if (key === "ArrowUp")    { e.preventDefault(); move(-1,0); return; }
  if (key === "ArrowDown")  { e.preventDefault(); move(1,0);  return; }
  if (key === "ArrowLeft")  { e.preventDefault(); move(0,-1); return; }
  if (key === "ArrowRight") { e.preventDefault(); move(0,1);  return; }

  if (key === "Backspace") {
    e.preventDefault();
    if (user[selected.r][selected.c]) {
      setLetterAt(selected.r, selected.c, "");
    } else {
      prevCell();
      setLetterAt(selected.r, selected.c, "");
    }
    return;
  }

  if (key === "Enter") {
    e.preventDefault();
    checkCurrentWord(true);
    return;
  }

  if (key.length === 1) {
    e.preventDefault();
    handleChar(key);
  }
});

/* Render clue lists */
function renderClues(){
  const acrossEl = document.getElementById("acrossClues");
  const downEl = document.getElementById("downClues");

  const acrossNums = Object.keys(ACROSS_CLUES).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
  acrossEl.innerHTML = acrossNums
    .map(n => `<div class="clue"><b>${n}.</b> ${ACROSS_CLUES[n]}</div>`)
    .join("");

  downEl.innerHTML = DOWN_LIST
    .slice()
    .sort((a,b)=>a[0]-b[0])
    .map(([n,_ans,clue]) => `<div class="clue"><b>${n}.</b> ${clue}</div>`)
    .join("");
}

/* Init */
renderGrid();
renderClues();

/* Click on grid focuses keyboard (helps mobile) */
gridEl.addEventListener("click", ()=>kbd.focus());
</script>

</body>
</html>
